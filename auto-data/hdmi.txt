################################################################################
##
## Filename: 	hdmiin.txt
##
## Project:	AutoFPGA, a utility for composing FPGA designs from peripherals
##
## Purpose:	
##
## Creator:	Dan Gisselquist, Ph.D.
##		Gisselquist Technology, LLC
##
################################################################################
##
## Copyright (C) 2017, Gisselquist Technology, LLC
##
## This program is free software (firmware): you can redistribute it and/or
## modify it under the terms of  the GNU General Public License as published
## by the Free Software Foundation, either version 3 of the License, or (at
## your option) any later version.
##
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
## for more details.
##
## You should have received a copy of the GNU General Public License along
## with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
## target there if the PDF file isn't present.)  If not, see
## <http://www.gnu.org/licenses/> for a copy.
##
## License:	GPL, v3, as defined and found on www.gnu.org,
##		http://www.gnu.org/licenses/gpl.html
##
##
################################################################################
##
##
@PREFIX=hdmiin
@TOP.PORTLIST=
		// HDMI input clock
		i_hdmi_in_clk_n, i_hdmi_in_clk_p
@TOP.IODECL=
	// HDMI input clock
	input	wire	i_hdmi_in_clk_n, i_hdmi_in_clk_p;
@TOP.DEFNS=
	wire	w_hdmi_in_clk, w_hdmi_in_clk_no_buf;
@TOP.MAIN=
		// HDMI input clock
		w_hdmi_in_clk
@TOP.INSERT=
	IBUFDS	hdmi_in_clk_ibuf(.I(i_hdmi_in_clk_p),
			.IB(i_hdmi_in_clk_n), .O(w_hdmi_in_clk_no_buf));
	BUFG	hdmi_in_clk_bufg(.I(w_hdmi_in_clk_no_buf), .O(w_hdmi_in_clk));
@TOP.MAIN=
		// HDMI input ports
		w_hdmi_in_clk
@MAIN.PORTLIST=
		// HDMI input ports
		i_hdmi_in_clk
@MAIN.IODECL=
	// HDMI input ports
	input	wire		i_hdmi_in_clk;
#
#
@PREFIX=hdmiout
@TOP.PORTLIST=
		// HDMI output clock
		o_hdmi_out_clk_n, o_hdmi_out_clk_p
@TOP.IODECL=
	// HDMI input clock
	output	wire	o_hdmi_out_clk_n, o_hdmi_out_clk_p;
@TOP.DEFNS=
	wire		w_hdmi_out_clk;
@TOP.MAIN=
		// HDMI output ports
		w_hdmi_out_clk
@TOP.INSERT=
	assign	w_hdmi_out_clk = w_hdmi_in_clk;
	xoddrb	hdmi_out_genclk(w_hdmi_out_clk, { 1'b1, 1'b0 },
			{ o_hdmi_out_clk_p, o_hdmi_out_clk_n });
@MAIN.PORTLIST=
		// HDMI output ports
		i_hdmi_out_clk
@MAIN.DEFNS=
	// HDMI output ports
	input	wire	i_hdmi_out_clk;
#
#
#
# The EDID I2C port for the HDMI input
@PREFIX=edin
@NADDR=32
@PTYPE=DOUBLE
@ACCESS=HDMI_IN_EDID_ACCESS
@TOP.PORTLIST=
		// HDMI input EDID I2C ports
		io_hdmi_in_scl, io_hdmi_in_sda
@TOP.IODECL=
	// HDMI input EDID I2C ports
	inout	wire	io_hdmi_in_scl, io_hdmi_in_sda;
@TOP.DEFNS=
	// HDMI command I2C wires, to support the EDID protocol
	// These are used to determine if the bus wires are to be set to zero
	// or not
	wire		w_hdmi_in_scl, w_hdmi_in_sda;
@TOP.MAIN=
	io_hdmi_in_scl, io_hdmi_in_sda, w_hdmi_in_scl, w_hdmi_in_sda
@TOP.INSERT=
	// The EDID I2C port for the HDMI source port
	//
	// We need to make certain we only force the pin to a zero (drain)
	// when trying to do so.  Otherwise we let it float (back) high.
	assign	io_hdmi_in_scl = (w_hdmi_in_scl) ? 1'bz : 1'b0;
	assign	io_hdmi_in_sda = (w_hdmi_in_sda) ? 1'bz : 1'b0;
@MAIN.PORTLIST=
		// HDMI input EDID I2C ports
		i_hdmi_in_scl, i_hdmi_in_sda, o_hdmi_in_scl, o_hdmi_in_sda
@MAIN.IODECL=
	// HDMI input EDID I2C ports
	input	wire		i_hdmi_in_scl, i_hdmi_in_sda;
	output	wire		o_hdmi_in_scl, o_hdmi_in_sda;
@MAIN.DEFNS=
	wire	[31:0]	edid_dbg;
@MAIN.INSERT=
	wbi2cslave	#(	.INITIAL_MEMA("edid_a.hex"),
				.INITIAL_MEMB("edid_b.hex"),
				.INITIAL_MEMC("edid_c.hex"),
				.INITIAL_MEMD("edid_d.hex")
				) the_input_edid(i_clk, 1'b0,
		wb_cyc, (wb_stb)&&(edin_sel), wb_we, wb_addr[4:0], wb_data,
			wb_sel, edin_ack, edin_stall, edin_data,
		i_hdmi_in_scl, i_hdmi_in_sda, o_hdmi_in_scl, o_hdmi_in_sda,
		edid_dbg);
@MAIN.ALT=
	assign	o_hdmi_in_scl = 1'b1;
	assign	o_hdmi_in_sda = 1'b1;
@REGS.NOTE=// HDMI EDID for the input HDMI port
@REGS.N=1
@REGS.0= 0 R_EDID_IN EDIN
@BDEFS.DEFN=
@BDEFS.IONAME=io_edin[32]
@BDEFS.IOTYPE=unsigned
@BDEFS.OSDEF=_BOARD_HAS_HDMI_IN_EDID
@BDEFS.OSVAL=static volatile @$THIS.BDEF.IOTYPE *const _edin = $((unsigned *)@$THIS.BASE);
#
#
#
@PREFIX=reflect
@TOP.PORTLIST=
	i_hdmi_rx_p, i_hdmi_rx_n,
	o_hdmi_tx_p, o_hdmi_tx_n
@TOP.IODECL=
	input	[2:0]	i_hdmi_rx_p, i_hdmi_rx_n;
	output	[2:0]	o_hdmi_tx_p, o_hdmi_tx_n;
@TOP.INSERT=
	wire	[2:0]	w_hdmi_v;
	IBUFDS	ihdmir(.I(i_hdmi_rx_p[0]), .IB(i_hdmi_rx_n[0]),.O(w_hdmi_v[0]));
	IBUFDS	ihdmig(.I(i_hdmi_rx_p[1]), .IB(i_hdmi_rx_n[1]),.O(w_hdmi_v[1]));
	IBUFDS	ihdmib(.I(i_hdmi_rx_p[2]), .IB(i_hdmi_rx_n[2]),.O(w_hdmi_v[2]));

	OBUFDS	ohdmir(.I(w_hdmi_v[0]), .O(o_hdmi_tx_p[0]),.OB(o_hdmi_tx_n[0]));
	OBUFDS	ohdmig(.I(w_hdmi_v[1]), .O(o_hdmi_tx_p[1]),.OB(o_hdmi_tx_n[1]));
	OBUFDS	ohdmib(.I(w_hdmi_v[2]), .O(o_hdmi_tx_p[2]),.OB(o_hdmi_tx_n[2]));
@PREFIX=scop_edid
@PTYPE=DOUBLE
@NADDR=2
@INT.SCOPE.WIRE=scop_edid_int
@INT.SCOPE.PIC=buspic
@MAIN.INSERT=
	wbscopc	theicscop(i_clk, 1'b1, edid_dbg[31], edid_dbg[30:0],
			i_clk, wb_cyc, (wb_stb)&&(scop_edid_sel), wb_we, wb_addr[0], wb_data,
			scop_edid_ack, scop_edid_stall, scop_edid_data,
			scop_edid_int);
@REGS.NOTE=// EDID/I2C Debug Scope
@REGS.N=2
@REGS.0= 0 R_EDID_SCOPC	ESCOPC ESCOPE
@REGS.1= 1 R_EDID_SCOPD	ESCOPD
