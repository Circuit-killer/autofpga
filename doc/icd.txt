AutoFPGA does all of its work based upon KEY/VALUE pairs.  Key/value pairs
are organized into a hierarchical, but unordered, structure which is then
referenced by the logic that follows.  The values themselves are either strings
or numbers.

Lines defining keys may begin as:
@KEY=	Defining a given key
@$KEY=	Defines a numeric key value that may need to be evaluated
@KEY+=	Concatenates the following onto the pre-existing string key.  If the
	key does not (yet) exist, it is created and initialized to this value.
@/KEY=	References a global key
@/KEY+=	Concatenates onto a global key


Lines not defining keys are either comment lines (lines beginning with either
## or # and a space), or lines appended to the value of the last key.

AutoFPGA document lines starting with @ specify a key name.  Lines starting with
a @$ specify an integer valued expression.  The key is given by the string
between the @ (or @$) and the ='s (minus any white space at the end, white
space at the beginning is not allowed).  KEYs are case sensitive.  By
convention, KEYs are in all caps, although keys with lower case letters are
allowed and used as names of particular file components.  For the discussion 
below, any keys will be identified by prefixing the key name with an @ sign.

Comments.  Lines beginning with either two hash marks, ##, or a single hash
followed by a space, as in "# ", are comment lines.  Other lines beginning
with "#", such as #define, are not comments, neither do lines containing "#"
in any location other than the first location contain comments.

KEYs are by convention all capitals.  They are also hierarchical.  Hence,
a key BDEFS.IONAME references the BDEFS set of key-value pairs, with the keyname
IONAME within that set.

Every device or bus master *must* contain a @PREFIX key.  This key will be used
as a unique string to identify the device.  As parsing takes place, all of the
keys for a given device will be placed into a key-value set prefixed by the
@PREFIX key.  Hence, for a device with name @PREFIX=uart, a definition such as
@NADDR=4 creates a key named @uart.NADDR and gives it the value 4. 

Keys defined prior to the first @PREFIX key are global keys, and are not given
any @PREFIX in front of them prior to being inserted into the master key-value
mapping.

Key definitions beginning with @$ are integer expressions that will be evaluated
before use.

Further, strings may reference other parts of the key-value mapping by placing
a @$ in front of a key name.  This value will then be replaced by the value
once that value is known.  Expressions may also be used when assigning to
things such as @$KEY, as in ...
@$KEY.EXPR=(1<<20)
@KEY.FORMAT=0x%08x
@KEY.VAL will be created with the calculated value
@KEY.STR will be created with the value formated as desired into a string
Once this expression has a value, a new key will be created, KEY.VAL, having
the integer value of this expression.  This value may be referenced via the
base @KEY.  Further, this value will be substituted wherever @$KEY exists
within any other VALUE's.  Which value it gets, either the number or the
string, is dependent upon the context and how it is referenced.

Peripheral devices *must* also contain a @PTYPE key.  This key can have one of
the following values:
	SINGLE	A peripheral with no internal address decoding, but
		whose output value (@PREFIX_data) is valid on any given clock.
		These peripherals are not allowed to stall the bus.
		These peripherals will be collected together.
	DOUBLE	A peripheral with internal address decoding, but no delays.
		Hence, the data value for this peripheral will always be valid
		one clock after the select line goes high.
		These peripherals are not allowed to stall the bus.
		These peripherals will also be collected together.
	MEMORY	A peripheral including information that needs to be placed into
		a linker script.  Examples of MEMORY can be block RAM's,
		SDRAM, or even FLASH.  MEMORY that fits the criteria for DOUBLE
		is also best given the MEMORY attribute instead.
	OTHER	Any peripheral that doesn't match the above.


Other tags include
NADDR	The number of uniquely addressable registers/ports this device has
/*
	Future: BUSTYPE, for now the default will be WB-B4/pipeline.
	Future values may include WB/classic, or perhaps even AXI and AXI-lite.
*/

TOP.PORTLIST
	This string gets added into the toplevel( portlist ) declaration,
	allowing each peripheral to control external wires.  If not specified,
	this is given by MAIN.PORTLIST.

TOP.IODECL
	This string includes the declarations for the portlist above, such as
	output wire o_value.  If not specified, this is given by MAIN.IODECL.

TOP.DEFNS
	Defines variables in toplevel.v
TOP.MAIN
	This string gets added into the main module instantiation, between
	the ( parentheses ).
TOP.INSERT
	Some peripherals need some cleanup.  Hence, after instantiating main,
	these need to do some logic.  Any variables needed here need to have
	been declared in TOP.DEFNS.

MAIN.PARAM
MAIN.PORTLIST
	Same as TOP.PORTLIST, only as applied to the main.v file
MAIN.IODECL
	Same as TOP.IODECL, only as applied to the main.v file
MAIN.DEFNS
MAIN.INSERT
MAIN.ALT

BASE	(Created and used internally)
MASK	(Created and used internally)
AWID

REGSDEFS.H.INCLUDE	Placed at the top of the regdefs.h file
REGS.NOTE	A comment to be placed at the beginning of the register list
		for this peripheral
REGS.N		The number of registers this peripheral has.  AutoFPGA will then
		look for keys of the form REGS.0 through REGS.(REGS.N-1).
REGS.0...?	Describes a register by name.  The first value is the offset
		within the address space of this device.  The second token
		is a string defining a C #def'd constant.  The third and
		subsequent tokens represent human readable names that may be
		associated with this register.
REGSDEFS.H.DEFNS	Placed with other definitions within regdefs.h
REGS.H.INSERT
I may change this to the following notation, though:
REGSDEFS.NOTE
REGS.<name>.ADDR	# Offset within the peripheral
REGS.<name>.UNAME(s)	# User-readable name
REGS.<name>.DESC(ription for LaTeX)


BDEF.DEFN
BDEF.IONAME
BDEF.IOTYPE
BDEF.OSDEF
BDEF.OSVAL
// defaults to static volatile @THIS.BDEF.IOTYPE *const @THIS.BDEF.IONAME = &((@THIS.BDEF.IOTYPE *)@THIS.BASE);
(deprecated) IONAME
(deprecated) CSTRUCT (now BDEF.DEFN)

XDC.FILE	If present, autofpga will open this file and look through it
		for commented lines defining pins that exist in our top
		level port list.  Lines beginning with a #, but not ##, will
		be uncommented and added the build.xdc file.  If no XDC.FILE
		key is given, then the build.xdc file will not be created.
XDC.INSERT	This line, if present, gets inserted verbatim at the bottom of
		the generated XDC file
UCF.FILE	Does the same thing with a UCF file as was done with the
		XDC.FILE, creating a build.ucf file when done.
UCF.INSERT	Adds lines to the UCF file, just as with the XDC.INSERT tag
		does for the XDC file.

LDSCRIPT.PTR	(Name to be used within the linker script)
LDSCRIPT.PSTR	(Permission string for the linker script)
LDSCRIPT.DEF	(Any definitions to be added to the linker script)

PIC.BUS		The name of a parameter to hold all of the interrupt wires
PIC.MAX		The maximum number of interrutps this one can have

INT.NAME.WIRE	Specifies that an interrupt with C #define name NAME is
		connected to the internal wire with its name given by this key
INT.NAME.PIC	Identifies which PIC this wire is connected to.  Any particular
		interrupt may be assigned to multipl PICs.  If so, these
		are listed on this line and separated by white space
INT.NAME.ID	Identifies which interrupt wire this device it connected to
